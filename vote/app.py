from flask import Flask, render_template, request, make_response, g, jsonifyfrom redis import Redisimport osimport socketimport randomimport jsonimport loggingimport mathimport pandas as pdimport numpy as npoption_a = os.getenv('OPTION_A', "Cats")option_b = os.getenv('OPTION_B', "Dogs")hostname = socket.gethostname()app = Flask(__name__)gunicorn_error_logger = logging.getLogger('gunicorn.error')app.logger.handlers.extend(gunicorn_error_logger.handlers)app.logger.setLevel(logging.INFO)def get_redis():    if not hasattr(g, 'redis'):        g.redis = Redis(host="redis", db=0, socket_timeout=5)    return g.redisratings = pd.read_csv('ratings.csv')#Funciones Pares Cercanosdef cosine_similarity_manual(vec1, vec2):    dot_product = sum(a * b for a, b in zip(vec1, vec2))    magnitude_vec1 = math.sqrt(sum(a**2 for a in vec1))    magnitude_vec2 = math.sqrt(sum(b**2 for b in vec2))        if magnitude_vec1 == 0 or magnitude_vec2 == 0:        return 0  # Evitar la división por cero        return dot_product / (magnitude_vec1 * magnitude_vec2)def find_nearest_neighbors_manual(user_id, ratings_df, num_neighbors=10):    # Filtrar las calificaciones del usuario específico    user_ratings = ratings_df[ratings_df['userId'] == user_id].drop(columns=['userId', 'timestamp']).values[0]    # Filtrar las calificaciones de los otros usuarios    other_users_ratings = ratings_df[ratings_df['userId'] != user_id].drop(columns=['userId', 'timestamp'])    # Calcular la similitud coseno entre el usuario específico y los demás usuarios    similarities = [        cosine_similarity_manual(user_ratings, row.values)        for _, row in other_users_ratings.iterrows()    ]    # Obtener los índices de los usuarios más cercanos    nearest_neighbors_indices = sorted(range(len(similarities)), key=lambda i: similarities[i], reverse=True)[:num_neighbors]    # Obtener los IDs de los usuarios más cercanos    nearest_neighbors_ids = ratings_df.iloc[nearest_neighbors_indices]['userId'].tolist()    return nearest_neighbors_idscosine = find_nearest_neighbors_manual(1, ratings)app.logger.info(cosine)def calculate_cosine_similarity(A, B):    valid_indices = [i for i, (x, y) in enumerate(zip(A, B)) if x is not None and y is not None]    A_valid = [A[i] for i in valid_indices]    B_valid = [B[i] for i in valid_indices]    dot_product = sum(x * y for x, y in zip(A_valid, B_valid))    norm_A = math.sqrt(sum(x**2 for x in A_valid))    norm_B = math.sqrt(sum(y**2 for y in B_valid))    similarity = dot_product / (norm_A * norm_B) if norm_A * norm_B != 0 else 0    return similarity@app.route("/", methods=['POST', 'GET'])def hello():    voter_id = request.cookies.get('voter_id')    if not voter_id:        voter_id = hex(random.getrandbits(64))[2:-1]    similarity = None    ratings_data = None    if request.method == 'POST':        redis = get_redis()                if 'vote' in request.form:            # ... (código de votación existente)        elif 'calculate' in request.form:            user_id = int(request.form.get('user_id'))                        # Calcular vecinos cercanos y guardar en Redis            cosine_neighbors = find_nearest_neighbors_manual(user_id, ratings)            app.logger.info('Calculated cosine neighbors for user %s: %s', user_id, cosine_neighbors)                        # Convertir la lista a formato JSON antes de almacenar en Redis            neighbors_data = json.dumps({'user_id': user_id, 'neighbors': cosine_neighbors})            redis.rpush('cosine_neighbors', neighbors_data)            if redis.exists('similarities'):            app.logger.info('Data uploaded to Redis successfully')        else:            app.logger.error('Failed to upload data to Redis')                    if redis.exists('cosine_neighbors'):            app.logger.info('Data uploaded to Redis successfully')        else:            app.logger.error('Failed to upload data to Redis')    resp = make_response(render_template(        'index.html',        option_a=option_a,        option_b=option_b,        hostname=hostname,        similarity=similarity,        ratings_data=ratings_data,    ))    resp.set_cookie('voter_id', voter_id)    return respif __name__ == "__main__":    app.run(host='0.0.0.0', port=80, debug=True, threaded=True)